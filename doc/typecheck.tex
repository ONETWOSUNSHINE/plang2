\documentclass[10pt,a4paper]{article}
\usepackage[a4paper]{geometry}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb}
\usepackage{indentfirst}

\begin{document}

\part*{Контроль типов}

\section{Индексаторы}

Пусть $ T $ -- это произвольный тип. Тогда $ zero(T) $ -- это индексатор, возвращающий ноль типа $ T $.
Например, $ zero(\textbf{nat})~\equiv~0 $.

Пусть $ T $ -- это произвольный тип, а $ t $ - это произвольный элемент типа $ T $. Тогда $ inc(T, t) $ -- это
индексатор, возвращающий элемент типа $ T $, следующий за $ t $.

\section{Переписываемые типы}

В контроль типов вводятся т.н. \textit{переписываемые} типы, т.е. типы, которые будут переписаны в
процессе вывода.

\subsection{Класс переписываемых типов}

Пусть $ L $ -- это некоторое выражение класса \textit{literal}. Тогда $ lit(L) $ -- это переписываемый тип
этого выражения.

Пусть $ A $ -- это произвольный тип. Тогда минимальный тип $ zero(A) $ -- это тип, обозначающий тип нулевого
элемента типа $ A $.

Пусть $ A $ и $ B $ -- это произвольные типы. Тогда $ add(A,~B) $ -- это переписываемый тип суммы
$ a~+~b $, где $ a $ и $ b $ -- это произвольные выражения типов $ A $ и $ B $ соответственно. Стоит
отметить, что $ add(A, ~B)~\equiv~add(B,~A) $.

Для остальных арифметических операций типы определяются аналогичным образом.

\subsection{Вывод переписываемых типов}

В решатель добавляются следующие правила для генерации типов выражений:

\begin{equation}
T(zero(A))~\equiv~zeroT(A)
\end{equation}

\begin{equation}
T(inc(a))~\equiv~add(A,~lit(1)),
\end{equation}
где $ a $ -- это произвольное выражение типа $ A $.

\begin{equation}
T(a~+~b)~\equiv~add(A,~B),
\end{equation}
где $ a $ и $ b $ -- это произвольные выражения типов $ A $ и $ B $ соответственно.

Следующие правила вывода для переписываемых типов обладают высоким приоритетом, т.е. выполняются в первую
очередь:

\begin{equation}
add(A,~zeroT(B))~\rightarrow~A
\end{equation}

\begin{equation}
add(A,~lit(0))~\rightarrow~A
\end{equation}

\begin{equation}
add(lit(a),~lit(b))~\rightarrow~lit(a~+~b)
\end{equation}

Так как численные значения $ lit(a) $ и $ lit(b) $ в последнем правиле известны, значение $ lit(a + b) $ может
быть вычислено в момент замены.

Следующие правила вывода для переписываемых типов обладают низким приоритетом, т.е. выполняются в последнюю
очередь:

\begin{equation}
zeroT(A)~\rightarrow~A_0,
\end{equation}
где $ A_0 $ -- это минимальный подтип $ A $, содержащий $ 0 $.

\begin{equation}
lit(n)~\rightarrow~A_n,
\end{equation}
где $ n $ - это элемент счетного типа A, а $ A_n $ -- это минимальный подтип $ A $, содержащий $ n $.

Следующее правило обладает низким приоритетом, и применяется лишь для целых типов $ A $ и $ B $:

\begin{equation}
add(A,~B)~\rightarrow~(A~\lor~B)_{+1},
\end{equation}
где $ T_{+1} $ - это увеличение битности целого типа $ T $ на единицу.

\section{Конструктор массива}

Конструктор массива имеет следующий вид:

\begin{equation}\label{constructor}
A~a~\equiv~[Field_1,~...,~Field_n],
\end{equation}
где $ Field_k $ -- это k-ый элемент конструктора \eqref{constructor}:
\begin{equation}\label{field}
Field_k~\equiv~I_k~i_k:~V_k~v_k
\end{equation}

Часть индексов $ I_k~i_k $ может отсутствовать в определении конструктора. В таком случае необходимо доопределить индексы.

Тип A, очевидно, имеет следующий вид:

\begin{equation}
A~\equiv~\textbf{array}(B,~D),
\end{equation}

где B - это базовый тип, тип элементов массива, а D - это тип-размерность массива.

\subsection{Условия для базового типа}

Базовый тип B -- это наименьший тип, в котором содержатся все типы элементов $ V_1, ..., V_n $.
В соответствии с этим утверждением формируется следующий набор формул:

\begin{center}
$ V_1 \leq B^{\vee} $
\\
....
\\
$ V_n \leq B^{\vee} $
\end{center}

\subsection{Условия для типа-размерности}

Вначале нужно доопределить отсутствующие индексы. Далее -- получить условия для типа-размерности.

\subsection{Доопределение индексов}

Введем тип $ I $, который содержит в себе все индексы: и определенные, и нет. В первую очередь, доопределим
начальный индекс $ i_0 $ следующим образом:

\begin{center}
$ i_0=\left\{
    \begin{array}{@{} l c @{}}
      i_0 & \text{, если индекс определен} \\
      zero(I) & \text{, если индекс не определен}
    \end{array}\right. $
\end{center}

Затем, доопределим оставшиеся индексы аналогичным образом:

\begin{center}
$ i_k=\left\{
    \begin{array}{@{} l c @{}}
      i_k & \text{, если индекс определен} \\
      inc(I, i_{k-1}) & \text{, если индекс не определен}
    \end{array}\right. $
\end{center}

Если в конструкторе \eqref{constructor} не определен ни один индекс, то вместо типа $ I $ следует использовать тип $ \textbf{nat} $.
В остальных случаях тип $ I $ -- это наименьший тип, содержащий в себе все типы индексов $ I_1,~...,~I_n $:

\begin{center}
$ I_1 \leq I^{\vee} $
\\
....
\\
$ I_n \leq I^{\vee} $
\end{center}

\subsection{Тип-размерность}

На данном этапе считается, что тип-размерности $ D $ -- это тип $ I $:

\begin{equation}
D^{\vee} \equiv I^{\vee}
\end{equation}

\end{document}
