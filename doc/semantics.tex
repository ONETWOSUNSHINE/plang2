% -*- coding: utf-8 -*-
\documentclass[12pt,a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\lstset{extendedchars=\true,inputencoding=utf8x}
\addtolength{\parskip}{\baselineskip}
\begin{document}

%Language P
\lstdefinelanguage{P}{
morekeywords={var, int, nat, formula, module, if, else, lemma, exists, pre, post, measure, Алгоритм},
escapechar=@
}

\lstset{language=P}

\part*{Контроль динамической семантики предикатной программы}

Для предикатной программы на внутреннем представлении строится набор теорий с формулами корректности предикатной программы. Во внутреннем представлении теория кодируется конструкцией МОДУЛЬ.

\section{Теории модуля}

Программа составлена из модулей. Модуль является единицей компиляции и содержит набор глобальных описаний и определения предикатов. Глобальные объекты модуля (типы, константы, формулы, константы), используемые в генерируемых теориях формируют главную теорию.

Для каждого определения предиката строится теория, имя которой совпадает с именем предиката. Набор теорий, создаваемый генератором формул корректности, состоит из главной теории, теорий, представленных в исходной программе и теорий, сгенерированных для определений предикатов. Набор теорий должен быть замкнутым: для всякого вхождения имени (формулы, структурного типа, переменной, \dots) имеется соответствующее описание, за исключением имен примитивных типов. Набор теорий (подмодулей) доступен из специального поля конструкции МОДУЛЬ, полученной трансляцией исходной программы во внутреннее представление.

Теория во внутреннем представлении (конструкция МОДУЛЬ) состоит из формул и утверждений. Локальные объекты (типы, константы, переменные), используемые в формулах и утверждениях, должны быть представлены как объекты генерируемого модуля. Глобальные объекты должны быть определены в других теориях, и эти теории должны присутствовать в списке импорта модуля. Если локальный объект строится на базе другого локального объекта, то последний должен быть определен ранее.

\section{Теория для определения предиката}

Для определения предиката \\
A(x: y) \underline{\textbf{pre}} P(x) \{ S(x: y) \} \underline{\textbf{post}} Q(x, y) \\
генерируется следующая теория: \\ \\
\textbf{theory} A \{ \\
<список импорта> \\
<список локальных типов> \\
\textbf{formula} P\_A( x) = P(x); \\
<леммы с формулами контроля динамической семантики  оператора S> \\
\}\\
Здесь P\_A   новое имя, образованное из имени A. Это имя должны отличаться от других имен, используемых в программе. В противном случае необходимо использовать другой способ именования формул для выражений предусловия.

Для определения предиката-гиперфункции \\
A(x: y \#1: z \#2) \underline{\textbf{pre}} P(x); pre 1: C(x) \{ W \} \underline{\textbf{post}} 1: S(x, y); \underline{\textbf{post}} 2: R(x, z)
генерируется следующая теория: \\
\textbf{theory} A \{ \\
	<список импорта> \\
	<список локальных типов> \\
  \textbf{formula} P\_A( x) = P(x); \\
	\textbf{formula} P1\_A(x) = C(x); \\
	< леммы с формулами корректности оператора W> \\
\} \\
Предикат P1\_A(x) используется для контроля корректности завершителей вида \#1 и \#2 в операторе W.

Образ генератора предиката, конструкции \underline{\textbf{predicate}} <определение предиката>, такой же, как и для определения предиката, что описано выше. При этом образ генератора предиката помещается в ту же теорию, что и образ определения предиката, содержащего генератор. Генератор предиката либо является аргументом некоторого вызова предиката, либо является результатом предиката, в теле которого находится. Привязка генератора к аргументу вызова или к результату предиката может проводиться также через локальную переменную предикактного типа. Таким образом, генератор ассоциирован с аргументом или результатом предикатного типа.


\section{Контроль динамической семантики}
Набор ситуаций в языковых конструкциях, в которых требуется контроль динамической семантики.

Текст леммы имеет следующий вид: \\
<имя леммы>: lemma <префикс> => <утверждение> \\
<префикс> состоит из конъюнкции предусловия и условий в условных операторах, обрамляющих текущую конструкцию. \\
P \& $C_1$ \& . . . \& $C_n$ ; $C_i$ - после if, !$C_i$ - после else. \\
Если <префикс>  пустой, телом леммы является <утверждение>.\\
<утверждение> задается определенным образом для каждой конкретной ситуации:

\subsection{Совместимость типов (при вызовах предикатов и присваивании)}

Примитивные типы: \\
nat < int < real \\
bool - должны совпадать \\
char - должны совпадать \\
Тип как параметр:  должны совпадать \\
Предикат: \\
H(…, predicate C(…) pre PC post QC, …) {…} //описание функции \\
B(…) pre PB post QB //описание предиката \\
H(…, B, …) //вызов \\
Кол-во аргументов и результатов должны совпадать, типы аргументов должны быть совместимы, типы результатов совпадать и должны быть истинны формулы QB => QC \& PC => PB. \\
Подтип: \\
С простым типом: базовой тип для подтипа должен быть совместим с данным простым типом. \\
С подтипом: \\
type T = subtype( type A: Texpr) \\
type S = subtype( type B: Sexpr) \\
Т а = S s 

Тип В должен быть совместим с типом А, и должна быть истинна формула Texpr => Sexpr. \\
Перечисление: должны совпадать \\
Структурные типы: \\
Структура: количество и имена полей должны совпадать, типы соответствующих полей - совместимы. \\
Объединение: количество полей и конструкторы соответствующих полей должны совпадать. \\
Множество: базовые типы должны быть совместимы. \\
Массив: тип элементов должны быть совместимы, измерения массива должны совпадать. 


\subsection{Соответствие типов аргументов вызова и типов аргументов в определении предиката}
\textbf{Конструкция}: \\
A(\dots y \dots: \dots) - определение предиката\\
A(\dots x \dots: \dots) - вызов предиката

\textbf{Атрибуты}: типы Tх и Tу.

\textbf{Правило}: тип аргумента  х совместим с типом у. \\
Тх - тип выражения (аргумента вызова)  х, Ту - тип аргумента у.

\textbf{Алгоритм}: \\
Если Тх != Ту, то проверить совместимость Тх с Ту.

\textbf{Имя леммы}: Call*номер*


\subsection{Совпадение типов результатов вызова и типов результатов в определении предиката}
\textbf{Конструкция}: \\
P(\dots: \dots A \dots) - определение предиката\\
P(\dots: \dots B \dots) - вызов предиката

\textbf{Атрибуты}: TA и TB - типы переменных А и В.

\textbf{Правило}: TA совпадает c TB.

\textbf{Алгоритм}: \\
Случай: А и В - простые типы. Тогда нужно проверить, что они совпадают. \\
Случай: A = Ar(n1, \dots , nk); B = Ar(m, \dots , mk). Тогда лемма: n = m, \dots nk = mk. \\
Случай: A = Ar(n1, \dots , nk); B = Ar1(m, \dots , mk). Тогда нужно проверить, что получаемые конструкторами Ar и Ar1 типы совпадают.

Например Ar(n) = array(real, 1..n1, \dots 1..nk) \\
Ar1(m) = array(real, 1..m1+1, \dots 1..mk+1) \\
Тогда проверяется, что типы array и real совпадают; создаются диапазоны Q(n1, \dots , nk) = (1 <= i <= n1) \& \dots \&(1 <= i <= nk); Q1(m1, \dots , mk) = (1 <= i <= m1) \& \dots \&(1 <= i <= mk); и проверяется, что выражения, полученные при подстановке конкретных значений в Q(n1, \dots , nk) и Q1(m1, \dots , mk) совпадают.


\textbf{Имя леммы}: CallResult*номер*


\subsection{Присваивание}
\textbf{Конструкция}: \\
y = x;

\textbf{Атрибуты}: типы х и у. Тх - тип выражения  х, Ту - тип переменной у.

\textbf{Правило}: типы Tх совместим типом Ту. В частности, проверяется что Тх является подтипом Ту, т.е. !!!!!!!!!!!!!1

\textbf{Алгоритм}: \\
Если Тх != Ту, то проверить совместимость Тх с Ту.

\textbf{Имя леммы}: Assign*номер*


\subsection{Switch}
\textbf{Конструкция}: \\
\begin{lstlisting}
switch(x) {
  case  alt1:
  case  alt2:
  ...
  case  altn:
  default:
}
\end{lstlisting}

\textbf{Атрибуты}: выражения или диапазоны alt1, alt2, \dots, altn, mini, maxi - границы i-го диапазона, тип х(с конечным диапазоном в случае отсутствия default'a).

\textbf{Правило}: значения альтернатив попарно различны (кроме проверок, которые делаются статически) \\
Если нет альтернативы по умолчанию(default), то проверить, что объединение альтернатив покрывает тип выражения x.

\textbf{Алгоритм}: \\
alti, altj - выражения: alti != altj $\forall$ i != j. \\
alti - выражение, altj - диапазон: (alti < min(altj)) \& (alti > max(altj)) $\forall$ i != j. \\
alti, altj - диапазоны: (min(alti) > max(altj)) $\vee$ (max(alti) < min(altj)) $\forall$ i != j. \\
При отсутствии default: x = alt1 $\vee$ ((x >= min2) \& (x <= max2)) $\vee$ \dots $\vee$ x = altn. \\ x = alti для выражения, (x >= minj) \& (x <= maxj) для диапазона

\textbf{Имя леммы}: Switch*номер*


\subsection{Оператор If}
\textbf{Конструкция}: \\
if (A)\{...\} else

\textbf{Атрибуты}: логическое выражение А и логическое условие D, составляемое из конъюнкции предусловия и условий в условных операторах, обрамляющих текущую конструкцию.

\textbf{Правило}: Ветви if и else  должны быть достижимы.

\textbf{Алгоритм}: \\
$\exists$x D \& B \\
$\exists$x D \& not B \\
x - набор переменных, находящиеся в D и B.

\textbf{Имя леммы}: If*номер*


\subsection{Проверка выхода индекса за границы массива}
\textbf{Конструкция}: \\
type M = array (type T, D)  - определение\\
M m[\dots]; \\
m[i] - взятие элемента

\textbf{Атрибуты}: диапазон D, a и b - границы и номер i.

\textbf{Правило}: i принадлежит диапазону индексов массива m.

\textbf{Алгоритм}: \\
(i >= a) \& (i <= b)

\textbf{Имя леммы}: Array*номер*


\subsection{Неделение на ноль}
\textbf{Конструкция}: \\
y/x

\textbf{Атрибуты}: типы х и у.

\textbf{Правило}: x не равен нулю.

\textbf{Алгоритм}: \\
х != 0

\textbf{Имя леммы}: Divide*номер*


\subsection{Определение массива по частям}
\textbf{Конструкция}: \\
M = array(T, D) \\
M m; \\
m = for(var j) { case A1 : \dots case A2: \dots \dots case An: \dots default: \dots }

\textbf{Атрибуты}: диапазон D, диапазоны или выражения Ai.

\textbf{Правило}: Ai попарно не пересекаются и не выходят за границы D. Если нету default, то объединение Ai должно быть равно D.

\textbf{Алгоритм}: \\
Ai != Aj $\forall$ i != j. Ai, Aj - выражения\\
(Ai < min(Aj)) \& (Ai > max(Aj)) $\forall$ i != j. Ai - выражение, Aj - дипапазон\\
(min(Ai) > max(Aj)) $\vee$ (max(Ai) < min(Aj)) $\forall$ i != j. Ai, Aj - диапазоны\\
(min(Аi) >= min(D)) \& (max(Ai) <= max(D)), если Ai - диапазон\\
(Ai >= min(D)) \& (Ai <= max(D)), если Ai - выражение \\
При отсутствии default: A1 $\cup$ A2 $\cup$ \dots $\cup$ An = D. Ai - для диапазона, \{Aj\} - для выражения.

\textbf{Имя леммы}: ArrayPart*номер*


\subsection{Модификация массива}
\textbf{Конструкция}: \\
type Vec(nat n) = array (real, 1..n); \\
perm(nat n, Vec(n) b, nat m, k : Vec(n) b') \\
\{ b' = b [k: b [m], m: b [k] ] \};

\textbf{Атрибуты}: массивы b и b', номера k и m.

\textbf{Правило}: k и m лежат в пределах диапазона массива и k не равно m.

\textbf{Алгоритм}: \\
(k >= 1) \& (k <= n) \& (m >= 1) \& (m <= n) \\
k != m

\textbf{Имя леммы}: ArrayMod*номер*


\subsection{Объединение массивов}
\textbf{Конструкция}: \\
M = array(T, D)  M1 = array(T, D1) M2 = array(T, D2) \dots Mn = array(T, Dn) \\
M = M1 + M2 + \dots + Mn

\textbf{Атрибуты}: массивы М, М1, М2, \dots Mn, выражения D, D1, D2, \dots Dn.

\textbf{Правило}: тип суммы массивов должен совпадать с типом позиции объединения массивов

\textbf{Алгоритм}: \\
D1 $\vee$ D2 $\vee$ \dots $\vee$ Dn \\
not (Di \& Dj) при i != j

\textbf{Имя леммы}: ArrayUnion*номер*


\subsection{Поле объединения}
\textbf{Конструкция}:
type S (\dots) = union ( \\
\dots \\
A (\dots Tс c, \dots) \\
\dots \\
); \\

\dots Имеется конструкция s.c \dots \\

\textbf{Атрибуты}: объединение S, конструктор В и в нем поле с, Тс - тип с.

\textbf{Правило}: Надо проверить, что s имеет тип В.

\textbf{Алгоритм}: \\
Пусть B? - распознаватель, соответствующий конструктору В. Тогда B?(s).

\textbf{Имя леммы}: FieldUnion*номер*


\end{document} 