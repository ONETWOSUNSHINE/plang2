\documentclass[10pt,a4paper]{article}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm,headheight=1cm,headsep=1cm,footskip=1cm}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{indentfirst}

%Language P
\lstdefinelanguage{P}{
morekeywords={var, int, nat, formula, module, if, else, lemma, exists, pre, post, measure},
escapechar=@
}

\lstset{language=P}

%Some settings
\lstset{extendedchars=\true,inputencoding=utf8x}
\addtolength{\parskip}{\baselineskip}

%Rule tables
\newcommand{\ruleI}[3] {
$$
\mathbf{#1:} ~~
\frac{#2}{#3}
$$
}

\newcommand{\ruleII}[4] {
\ruleI{#1}
{\genfrac{}{}{0pt}{0}{#2}{#3}}
{#4}
}

\newcommand{\ruleIII}[5] {
\ruleII{#1}
{\genfrac{}{}{0pt}{0}{#2}{#3}}
{#4}
{#5}
}

%Numered formulas
\newcommand{\numformula}[2] {
\begin{equation}
\label{eq:#1}
#2
\end{equation}
}

\newcommand{\lnkformula}[1] {
\eqref{eq:#1}
}

\begin{document}

\part*{Проект генератора формул корректности предикатной программы}

Для предикатной программы на внутреннем представлении и спецификаций (в виде предусловий и постусловий предикатов) генерируется набор теорий с формулами корректности предикатной программы. Во внутреннем представлении теория кодируется конструкцией МОДУЛЬ.

\section{Теория модуля}
Программа составлена из модулей. Модуль является единицей компиляции, содержащей набор глобальных описаний и определений предикатов программы. Глобальные объекты модуля (типы, константы, формулы, перменные), используетмые в генерируемых теориях, формируют \textit{главную теорию}.

Для каждого определения предиката строится теория, имя которй совпадает с именем предиката.

Набор теорий, создаваемый генератором формул корректности, состоит из главной теории и теорий, сгенерированных для определений предикатов. Набор теорий должен быть замкнутым: для всякого вхождения имени (формулы, структурного типа, переменной, …) имеется соответствующее описание, за исключением имен примитивных типов. Набор теорий (подмодулей) доступен из специального поля конструкции МОДУЛЬ, полученной трансляцией исходной программы во внутреннее представление.

Теория во внутреннем представлении (конструкция МОДУЛЬ) состоит из формул и утверждений. Локальные объекты (типы, константы, переменные), используемые в формулах и утвержлениях, должны быть представлены как объекты генерируемого модуля. Глобальные объекты должны быть определены в других теориях, и эти теории должны присутствовать в списке импорта модуля. Если локальный объект строится на базе другого локального объекта, то последний должен быть определен ранее.

\section{Теория для определения предиката}

Для определения предиката

\begin{center}
A(x: y) \underline{\textbf{pre}} P(x) \{ S(x: y) \} \underline{\textbf{post}} Q(x, y)
\end{center}

тотальная корректность определяется формулой:


\numformula{total_corr} {
Corr(S,~P,~Q) \equiv \forall x,~y.~P(x) \Rightarrow [~L(S(x:~y)) \Rightarrow Q(x,~y)~] \land \exists y.~L(S(x:~y))
}

В случае рекурсивного определения предиката A используется следующая схема доказательства по индукции для некоторого произвольного утверждения W(z):

\numformula{induct} {
\forall t \in X ~[(\forall u \in X~m(u)<m(t) \Rightarrow W(u)) \Rightarrow W(t)]~ \Rightarrow ~\forall z \in X ~ W(z)
}

Здесь m - функция типа \textbf{nat}, определяющая значение меры над набором аргументов x. Опрелелим:

\begin{center}
$ Induct(t,~A) \equiv \forall u.~m(u)<m(t) \Rightarrow Corr(A(u:~y),~P,~Q) $
$ Corr(t,~A,~K,~P,~Q) \equiv Induct(t,~A) \Rightarrow Corr(K,~P,~Q) $
\end{center}

Здесь K - произвольный оператор, содержащий рекурсивный вызов предиката A. При этом переменные набора t могут встречаться в составе аргументов оператора K. Тогда индукционная схема \lnkformula{induct} следующим образом переписывается для доказательства корректности рекурсивного определения предиката A:

\ruleI {R0}
{Corr(x,~A,~S(x:~y),~P,~Q)}
{Corr(A,~P,~Q)}

Далее условимся, что при отсутсвии рекурсивного вызова внутри оператора K запись Corr(t, A, K, P, Q) будет эквивалентна Corr(K, P, Q). Введем обозначенияе для предусловия рекурсивного вызова:

\begin{center}
$ P*(u) \equiv m(u)<m(t) \land P(u) $
\end{center}

В случае нерекусивного вызова запись P*(u) эквивалентна P(u). Также определим:

\begin{center}
$ IndCorr(t,~A) \equiv Induct(t,~A) $ для рекусивного предиката A
$ IndCorr(t,~A) \equiv Corr(A,~P,~Q) $ для нерекусивного предиката A
\end{center}

Если спецификация [P(x),~Q(x,~y)] однозначна, то корректность определения предиката реализуется правилом (Теорема 1):

\ruleI {T1}
{T(P(x),~Q(x,~y)); ~~P(x) \land Q(x,~y) \Rightarrow L(S(x:~y))}
{Corr(S(x:~y),~P(x),~Q(x,~y))}

где L(S(x: y)) - логика оператора S(x: y), а формула T(P(x), Q(x, y)) определяет тотальность спецификации:

\numformula{spectotal} {
T(P(x),~Q(x,~y)) \equiv P(x) \Rightarrow \exists y.~Q(x,~y)
}

Применение правила T1 для определения предиката A дает следующую теорию, представленную модулем:

\begin{lstlisting}
module A;
    <@описания локальных объектов@>
    formula P_A( x) = P(x);
    formula Q_A(x, y) = Q(x, y);
    A_total: lemma P_A(x) => exists y. Q_A(x, y);
    <@леммы с формулами корректности оператора S относительно cпецификации [P(x), Q(x, y)]@>
\end{lstlisting}

Здесь P\_A и Q\_A - новые имена, образованные из имени A. Эти имена должны отличаться от других имен, используемых в программе. В противном случае необходимо использовать другой способ именования формул для выражений предусловия и/или постусловия.

Применение правила T1 заключается в замене цели Corr(S(x: y), P(x), Q(x, y)) двумя посылками правила T1. Первая посылка дает генерацию леммы с именем A\_total. Вторая посылка правила T1 определяет новую цель $ P(x) \land Q(x,~y) \Rightarrow L(S(x:~y)) $, для которой ищется соответствующее правило в соответствии со структурой оператора S(x: y). Применение этого правила дает новые посылки, которые превращаются в леммы или в новые цели, для которых применяются нужные правила и т.д. пока не достигнем простейших операторов присваивания. Таким образом, строится дерево целей, листья которого определяют леммы генерируемой теории.

Для определения предиката-гиперфункции

\begin{center}
\par A(x: y \#1: z \#2) \underline{\textbf{pre}} P(x); \underline{\textbf{pre}} 1: C(x) \{ W \} \underline{\textbf{post}} 1: S(x, y); \underline{\textbf{post}} 2: R(x, z)
\end{center}

генерируется следующая теория:

\begin{lstlisting}
module A;
    <@описания локальных объектов@>
    formula P_A( x) = P(x);
    formula Q_A(x, y) = Q(x, y);
    A_total: lemma P_A(x) => exists y. Q_A(x, y);
    formula P1_A(x) = C(x);
    formula Q1_A(x, y) = S(x, y);
    formula Q2_A(x, z) = R(x, z);
    A_total1: lemma P_A(x) & P1_A(x) => (exists y. Q1_A(x, y));
    A_total2: lemma P_A(x) & not P1_A(x) => (exists z. Q2_A(x, z));
    formula spec_A(x, y, z) = P_A(x) & (P1_A(x) ? Q1_A(x, y) : Q2_A(x, z));
    <@леммы с формулами корректности оператора W@>
\end{lstlisting}

Предикат spec\_A есть конъюнкция предусловия и постусловия предиката A. Если первая ветвь гиперфункции имеет пустой набор результатов, то постусловие Q1\_A и лемма тотальности A\_total1 ветви отсутствуют, а spec\_A имеет вид:

\begin{center}
\begin{lstlisting}
formula spec_A(x, y, z) = P_A(x) & (P1_A(x) or Q2_A(x, z));
\end{lstlisting}
\end{center}

Если вторая ветвь имеет пустой набор результатов, то

\begin{center}
\begin{lstlisting}
formula spec_A(x, y, z) = P_A(x) & (P1_A(x) => Q1_A(x, y));
\end{lstlisting}
\end{center}

Образ генератора предиката, конструкции \underline{\textbf{predicate}} <определение предиката>, такой же, как и для определения предиката, что описано выше. При этом образ генератора предиката помещается в ту же теорию, что и образ определения предиката, содержащего генератор. Генератор предиката либо является аргументом некоторого вызова предиката, либо является результатом предиката, в теле которого находится. Привязка генератора к аргументу вызова или к результату предиката может проводиться также через локальную переменную предикактного типа. Таким образом, генератор ассоциирован с аргументом или результатом предикатного типа. Предусловие и постусловие предикатного типа используются в качестве предусловия и постусловия генератора при получении образа предиката. Здесь должно проводиться доказательство по системе правил общего вида с возможно неоднозначной спецификацией, поскольку программы с параметрами предикатного типа как правило имеют неоднозначную спецификацию.

\section{Правила декомпозиции доказательства корректности в случае произвольной спецификации}

Предположим, что наборы x, y и z – не пересекаются, а набор x может быть пустым.

\subsection{Операторы суперпозиции, параллельный и условный операторы.Случай отсутствия спецификаций}
\label{ex:specnotex}

Допустим, для параллельного оператора L(A(x: y) ||  B(x: z)) постусловие представимо в виде конъюнкции предикатов $ Q(x,~y) \land R(x,~z) $.

\ruleI{QP}
{Corr(A,~t,~B,~P,~Q);~~Corr(A,~t,~C,~P,~R)}
{Corr(A,~t,~B(x:~y)||C(x:~z),~P(x),~Q(x,~y) \land R(x,~z))}

\ruleI{QC}
{Corr(A,~t,~B,~P(x) \land E,~Q);~~Corr(A,~t,~C,~P(x) \land \urcorner E,~Q)}
{Corr(A,~t, ~\mathbf{if}~(E)~B(x:~y)~\mathbf{else}~C(x:~y),~P(x),~Q(x, y))}

\ruleII{QS}
{P(x) \vdash \exists z.~L(B(x:~z));}
{Corr(A,~t,~C(z:~y),~P(x) \land L(B(x:~z)),~Q(x,~y))}
{Corr(A,~t,~B(x:~z);~C(z:~y),~P(x),~Q(x,~y))}

\ruleII{QSB}
{Corr(A,~t,~B,~P_B,~Q_B);~~P(x) \vdash P_B(x)}
{Corr(A,~t,~C(z:~y),~P(x) \land Q_B(x,~z),~Q(x,~y))}
{Corr(A,~t,~B(x:~z);C(z:~y),~P(x),~Q(x,~y))}

\subsection{Операторы суперпозиции, параллельный и условный операторы с корректными подоператорами.}

\ruleII{RP}
{Corr(A,~t,~B,~P_B,~Q_B);~~Corr(A,~t,~C,~P_C,~Q_C);}
{P(x) \vdash P^*_B(x) \land P^*_C(x);~~Q_B(x,~y) \land Q_C(x,~z) \vdash Q(x,~y,~z)}
{Corr(A,~t,~B(x:~y)||C(x:~z),~P(x),~Q(x,~y,~z))}

\ruleIII{RS}
{Corr(A,~t,~B,~P_B,~Q_B);~~Corr(A,~t,~C,~P_C,~Q_C);}
{P(x) \vdash P^*_B(x) \land \forall z.~Q_B(x,~z) \Rightarrow P^*_C(z);}
{P(x) \land \exists z.~Q_B(x,~z) \land Q_C(z,~y) \vdash Q(x,~y)}
{Corr(A,~t,~B(x:~z);C(z:~y),~P(x),~Q(x,~y))}

\ruleIII{RC}
{Corr(A,~t,~B,~P_B,~Q_B);~~Corr(A,~t,~C,~P_C,~Q_C);}
{P(x) \land E \vdash P^*_B(x);~~P(x) \land \exists E \vdash P^*_C(x);}
{P(x) \land E \land Q_B(x,~y)\vdash Q(x,~y);~~P(x) \land \exists E \land Q_C(x,~y) \vdash Q(x,~y)}
{Corr(A,~t,~\mathbf{if}~(E)~B(x:~y)~\mathbf{else}~C(x:~y),~P(x),~Q(x,~y))}

\ruleII{RB}
{Corr(A,~t,~B,~P_B,~Q_B);~~Corr(A,~t,~C,~P_C,~Q_C);~~SV(P_B(x),~Q_B(x,~y));}
{P(x) \vdash P^*_B(x) \land P^*_C(B(x));~~P(x) \land Q_C(B(x),~y) \vdash Q(x,~y)}
{Corr(A,~t,~C(B(x):~y),~P(x),~Q(x,~y))}

\section{Правила декомпозиции доказательства корректности в случае однозначной спецификации}

Определим алгоритм генерации формул корректности для доказательства истинности формулы:

\numformula{genalg} {
R(x,~y) \Rightarrow L(S(x:~y))
}

Здесь S - оператор в правой части определения предиката, R(x, y) есть спецификация предиката $ P(x) \land Q(x, y) $ или любая другая формула, имеющая вид конюнкции формул. В принципе, было бы достаточно превратить L(S) в формулу исчисления предикатов в соответствии с логической семантикой. В результате, получили бы формулу, длина которой не меньше, чем оператор S. Чтобы упростить последующее доказательство верификатором, определим механизм сведения доказательства формулы \lnkformula{genalg} к доказательству более простых (коротких) формул, в зависимости от структуры оператора S. Итогом прцесса сведения является раскрытие (устранение) всех вхождений вызовов L(…) в доказываемых формулах. Механизм сведения базируется на системе правил вывода и описан в данном разделе.

В зависимости от структуры оператора S применение правил вывода сводит доказательство формулы \lnkformula{genalg} к более коротким формулам вида \lnkformula{short1} и \lnkformula{short2}:

\begin{center}
\numformula{short1} {R(x)~\Rightarrow~\exists y.~L(S(x:~y))}
\numformula{short2} {R(x) \land L(S(x:~y))~\Rightarrow~H(x,~y)}
\end{center}

Вхождение оператора S в формуле \lnkformula{short1} называется \textit{позицией квантора существования} для оператора S. Вхождение оператора S в формуле \lnkformula{short2} называется вхождением оператора S \textit{в левой части} правила. Отметим, что формула H(x, y) может иметь вид L(B(x: y)) для некоторого оператора B. В этом случае более приоритетным является раскрытие вхождения L(S(x: y)). Правила раскрытия вхождения оператора в левой части описаны в разделе~\ref{ex:leftside}.

Многократное применение правил вывода, описанных ниже, для доказательства формулы \lnkformula{genalg} приводит ее к набору формул, не содержащих вхождений вида L(…). Каждая из таких формул называется \textit{формулой корректности} оператора S(x: y). Когда в процессе применения правил генерируется очередная формула корректности, то эта формула оформляется в виде леммы.

Представленная ниже система правил вывода покрывает все виды операторов для разных вхождений вызовов L(…) в формулах вида \lnkformula{genalg}, \lnkformula{short1} и \lnkformula{short2}. Таким образом, алгоритм генерации формул корректности определен для произвольной предикатной программы. Для оператора с иерархической структурой построение формул сводится к построению формул для подоператоров. Наконец, для вызова предиката генерируются все необходимые формулы, что завершает процесс сведения. Процесс генерации формул корректности для определения предиката можно реализовать в рамках одного просмотра тела предиката. Исключение составляют сложные формы оператора суперпозиции, для которых требуется два просмотра отдельных подоператоров.

Применение общих правил, описанных в разделе~\ref{ex:specnotex}, к оператору суперпозиции, у которого первый оператор является вызовом предиката, приводит к дублированию некоторых формул корректности. Чтобы избежать дублирования и упростить многоступенчатый процесс сведения, применяется специализированная система правил, описанная в разделе~\ref{ex:suppredcall}.

Оператор суперпозиции A; B; C удобнее иметь в структурированном  виде A; \{B; C\}. Аналогичное структурирование предполагается для параллельного оператора A || B || C. Условный оператор структурирован нужным образом и не требует преобразований. При генерации формул корректности, оператор выбора \textbf{switch}(a)\{\textbf{case} b: A … \} рассматривается как условный оператор \textbf{if}(a = b) A \textbf{else} B, где оператор B представляет оставшуюся часть оператора выбора начиная со второй альтернативы. Если в свою очередь B - оператор выбора, то он далее рассматривается как преобразованный в условный оператор.

Итак, исходным является правило T1:

\ruleI{T1}
{T(P(x),~Q(x, y));~~P(x) \land Q(x,~y) \Rightarrow L(S(x:~y))}
{Corr(S(x:~y),~P(x),~Q(x,~y))}

На примере данного правила введем обозначения. Формулы  T(P(x), Q(x, y)) и $ P(x) \land Q(x,~y) \Rightarrow L(S(x:~y)) $ называются посылками правила T1 и обозначаются, соответсвенно, T1.1 и T1.2.

\subsection{Операторы суперпозиции, параллельный и условный операторы}

Допустим, наборы переменных x, y и z – не пересекаются, а набор x может быть пустым. Представим правила для оператора суперпозиции B(x: z); C(x, z: y), параллельного оператора B(x: y) || C(x: z) и условного оператора \textbf{if} (E) B(x: y) \textbf{else} C(x: y).

\ruleI{FS}
{R(x,~y) \vdash \exists z.~L(B(x:~z));~~R(x,~y) \land L(B(x:~z)) \vdash L(C(x,~z:~y))}
{R(x,~y) \vdash L(B(x:~z);~C(x,~z:~y))}

\ruleI{FP}
{R(x,~y,~z) \vdash L(B(x,~y));~~R(x,~y,~z) \vdash L(C(x,~z))}
{R(x,~y) \vdash L(B(x:~y)~||~C(x:~z))}

\ruleI{FC}
{R(x,~y) \land E \vdash L(B(x:~y));~~R(x,~y) \land \urcorner E \vdash L(C(x:~y))}
{R(x,~y) \vdash L(\mathbf{if}~(E)~B(x:~y)~\mathbf{else}~C(x:~y))}

Допустим, наборы переменных x, y,  z и t – не пересекаются, а набор x может быть пустым. Представим правило для обобщенного оператора суперпозиции B(x: z, t); C(x, z: y).

\ruleII{FSG}
{R(x,~t,~y) \vdash \exists z,~t.~L(B(x:~z,~t));}
{R(x,~t,~y) \land L(B(x:~z,~t1)) \vdash L(C(x,~z:~y)) \land t = t1}
{R(x,~t,~y) \vdash L(B(x:~z,~t);~C(x,~z:~y))}

Декомпозиция посылки \textbf{FSG.2} далее проводится отдельно для каждого конъюнкта L(C(x, z: y)) и t = t1. Хотя, для удобства последующего автоматического доказательства, было бы полезно объеденить полученные леммы.

Посылка \textbf{FS1.1} имеет вид \lnkformula{short1}, а \textbf{FS1.2} - \lnkformula{short2}. Для раскрытия вхождения L(B(x: z, t1)) в левой части посылки \textbf{FS1.2} далее применяется правило, описанное в разделе~\ref{ex:leftside}. После того, как все вхождения конъюнктов вида L( … ) в левой части \textbf{FS1.2} будут раскрыты, полученная посылка делится на две посылки:

\textbf{FS4.1:} $ R1(…) \vdash L(C(x,~z:~y)) $
\par\textbf{FS4.2:} $ R1(…) \vdash t = t1 $

Правило \textbf{FS4.1} имеет вид \lnkformula{genalg}, а правило \textbf{FS4.2} оформляется в виде леммы и добавляется к теории.

\subsection{Операторы в позиции квантора существования}

В приведенных правилах наборы переменных x, y,  z и t – не пересекаются, а набор x может быть пустым.

\ruleI{ES}
{R(x) \vdash \exists z.~L(A(x:~z));~~R(x) \land L(A(x:~z)) \vdash \exists y.~L(B(x,~z:~y)))}
{R(x) \vdash \exists y.~L(A(x:~z);~B(x,~z:~y))}

\ruleI{ESG}
{R(x) \vdash \exists z,~t.~L(A(x:~z,~t));~~R(x) \land L(A(x:~z,~t)) \vdash \exists y.~B(x,~z:~y))}
{R(x) \vdash \exists y.~L(A(x:~z,~t);~B(x,~z:~y))}

\ruleI{EP}
{R(x,~y,~z) \vdash \exists y. L(A(x:~y));~~R(x,~y,~z) \vdash \exists z.~L(B(x:~z))}
{R(x) \vdash \exists y.~L(A(x:~y)~||~B(x:~z))}

\ruleI{EC}
{R(x,~y) \land C \vdash \exists y.~L (A(x:~y));~~R(x,~y) \land \urcorner C \vdash \exists y.~L(B(x:~y))}
{R(x) \vdash \exists y.~L(\mathbf{if}~(C)~A(x:~y)~\mathbf{else}~B(x:~y))}

\subsection{Вызов предиката}

\ruleII{FB}
{Corr(A(x:~y),~P(x),~Q(x,~y));}
{SV(P(x),~Q(x,~y));~~R(x,~y) \vdash P(x) \land Q(x,~y)}
{R(x,~y) \vdash L(A(x:~y))}

Предикат SV определяет однозначность спецификации:

\numformula{singlespec} {
SV(P(x),~Q(x,~y)) \equiv P(x) \land Q(x,~y1) \land Q(x,~y2) \Rightarrow y1 = y2 .
}

Правило \textbf{FB} применимо для произвольного оператора A(x: y). Однако реальная необходимость правила \textbf{FB} возниает, когда A(x: y) - нерекурсивный вызов предиката. В этом случае посылка Corr(A(x: y), P(x), Q(x, y)) эквивалентна корректности определения предиката A с данными предусловием и постусловием. При этом истинность посылки SV(P(x), Q(x, y)) гарантируется автоматически, если корректность определения предиката A доказана с помощью правила \textbf{T1}.

\ruleI{EB}
{Corr(A(x:~y),~P(x),~Q(x,~y));~~R(x) \vdash P(x)}
{R(x,~y) \vdash \exists y.~L(A(x:~y))}

Рассмотрим определение предиката A с рекурсивным вызовом A(u: y1) в теле предиката K(x: y):

\numformula{recpred} {
A(x:~y)~\underline{\mathbf{pre}}~P(x)~{ K(x:~y)}~\underline{\mathbf{post}}~Q(x,~y)~\textbf{measure}~m(x)
}

В теории для опрелеления предиката A дополнительно генерируется описание для функции меры:

\begin{center}
\textbf{formula} m(x: \textbf{nat}) = <выражение, зависящее от x >;
\end{center}

Здесь m - новое имя переменной, отличное от других используемых имен.

Для рекурсивно определяемого предиката \lnkformula{recpred} правило \textbf{T1} неприменимо. Используется правило \textbf{FR}:

\ruleI{FR}
{T(P(x),~Q(x,~y));~~Induct(x) \land P(x) \land Q(x,~y) \vdash L(K(x:~y))}
{Corr(K(x:~y),~P(x),~Q(x,~y))}

\begin{center}
$ Induct(x) \equiv \forall u.~m(u)<m(x) \Rightarrow V(u) $ \\
$ V(x) \equiv P(x) \land Q(x,~y) \Rightarrow L(K(x:~y)) $
\end{center}

Доказательство корректности рекурсивного вызова A(u: y1) реализуется с помощью правила:

\ruleI{FBR}
{R(u,~x,~y1) \vdash m(u)<m(x) \land P(u) \land Q(u,~y1)}
{Induct(x) \land R(u,~x,~y1) \land L(A(u:~y1))}

Для вхождения рекурсивного вызова A(u: y1) в позиции квантора существования применяется формула:

\ruleI{FER}
{R(u,~x) \vdash m(u)<m(x) \land P(u)}
{Induct(x) \land R(u,~x) \vdash \exists y.~L(A(u:~y))}

\subsection{Выражения в качестве аргументов вызова предиката}

Генерируемые леммы с формулами корректности для вызовов предикатов, а также вызовов гиперфункций, представлены выше для случая, когда в качестве аргументов вызова используются переменные. В случае использования выражений в качестве аргументов построение формул корректности реализуется на основе леммы 2. Для каждой переменной-аргумента все ее вхождения в генерируемых формулах заменяются выражением, находящимся в позиции данной переменной-аргумента. Имена переменных-аргументов выбираются таким образом, чтобы замена их выражениями не привела к коллизиям. Если выражение, подставляемое в качестве аргумента, имеет предусловие P(x), отличное от \textbf{true}, генерируется лемма с дополнительным условием корректности $ R(x) \Rightarrow P(x) $, где R(x) определяет текущий набор посылок.

\subsection{Оператор в левой части формулы}
\label{ex:leftside}

Здесь определяются правила для раскрытия вхождения конъюнкта вида L(A(x: z)) в левой части формул вида \lnkformula{short2}. В приведенных правилах наборы переменных x, y, z и t – не пересекаются, а набор x может быть пустым.

\ruleI{FLP}
{R(x) \land L(A(x,~y)) \land L(B(x, z)) \vdash H(x,~y,~z)}
{R(x) \land L(A(x:~y)||B(x:~z)) \vdash H(x,~y,~z)}

\ruleI{FLC}
{R(x) \land C \land L(A(x:~y)) \vdash H(x,~y);~~R(x)\land \urcorner C \land L(B(x:~y)) \vdash H(x,~y)}
{R(x) \land L(\mathbf{if}~(C)~A(x:~y)~\mathbf{else}~B(x:~y))\vdash H(x,~y)}

\ruleI{FLS}
{R(x) \land L(A(x:~z)) \land L(B(x,~z:~y)) \vdash H(x,~y)}
{R(x) \land L(A(x:~z);~B(x,~z:~y)) \vdash H(x,~y)}

\ruleI{FLSG}
{R(x) \land L(A(x:~z,~t)) \land L(B(x,~z:~y)) \vdash H(x,~y,~t)}
{R(x) \land L(A(x:~z,~t);~B(x,~z:~y)) \vdash H(x,~y,~t)}

Пусть имеется рекурсивное или нерекурсивное определение предиката :

\begin{center}
A(x: y) \underline{\textbf{pre}} P(x) \{ \ldots \} \underline{\textbf{post}} Q(x, y) \textbf{measure} <выражение, зависящее от x >
\end{center}

Правило для рекурсивного или нерекурсивного вызова A(x: z):

\ruleI{FLB}
{R(x,~y) \vdash P*(x);~~R(x,~y) \land Q(x,~z) \vdash H(x,~y,~z)}
{IndCorr(t,~A) \land R(x,~y)\land L(A(x:~z)) \vdash H(x,~y,~z)}

\subsection{Оператор суперпозии с вызовом предиката в качестве первого оператора}
\label{ex:suppredcall}

В процессе применения правил возможна генерация одинаковых лемм, например, при повторной проврке истинности предусловия. Чтобы избежать дублирования и упростить многоступенчатый процесс декомпозиции доказательства корректности, применяется спеиализированная система правил. Допустим A(x: z) - корректный нерекурсивный вызов предиката.

\ruleII{FS2}
{Corr(A(x:~y),~P(x),~Q(x,~y));}
{R(x,~y) \vdash P(x);~~R(x,~y) \land Q(x,~z) \vdash L(B(x,~z:~y))}
{R(x,~y) \Rightarrow L(A(x:~z);~B(x,~z:~y))}

Пусть имеется оператор суперпозиции в определении предиката A:

\numformula{suppred} {
A(x:~y) \equiv P(x)~\{\ldots A(u:~y1);~B(u,~y1:~z)~\ldots \}~Q(x,~y)
}

Для рекурсивного вызова A(u: y1) в суперпозиции используется правило:

\ruleIII{FS3}
{T(P(x),~Q(x,~y));}
{R(u,~x,~z) \vdash m(u)<m(x) \land P(u);}
{R(u,~x,~z) \land Q(u,~y1) \vdash L(B(u,~y1:~z))}
{Induct(x) \land R(u,~x,~z) \vdash L(A(u:~y1);~B(u,~y1:~z))}

Допустим A(x: z) - корректный нерекурсивный вызов предиката.

\ruleII{FE5}
{Corr(A(x:~y),~P(x),~Q(x,~y));}
{R(x) \vdash P(x);~~R(x) \land Q(x, z) \vdash \exists y.~L(B(x,~z:~y))}
{R(x) \vdash \exists y.~L(A(x:~z);~B(x,~z:~y))}

Для рекурсивного вызова A(u: y1) в суперпозиции в определении \lnkformula{suppred} используется правило:

\ruleIII{FE6}
{T(P(x),~Q(x,~y));}
{R(u,~x,~z) \vdash m(u)<m(x) \land P(u);}
{R(u,~x) \land Q(u,~y1) \vdash \exists z.~L(B(u,~y1:~z))}
{Induct(x) \land R(u,~x,~z) \vdash L(A(u:~y1);~B(u,~y1:~z))}

Допустим B(x: z, t), нерекурсивный вызов предиката, является первым в обощенной суперпозиции.

\ruleII{FS4}
{Corr(B(x:~z,~t),~P(x),~Q(x,~z,~t));}
{R(x,~t,~y) \vdash P(x);~~R(x,~t,~y) \land Q(x,~z,~t1) \vdash L(C(x,~z:~y)) \land t = t1}
{R(x,~t,~y) \vdash L(B(x:~z,~t);~C(x,~z:~y))}

\ruleII{FE7}
{Corr(B(x:~z,~t),~P(x),~Q(x,~z,~t));}
{R(x) \vdash P(x);~~R(x,~t,~y) \land Q(x,~z,~t1) \vdash \exists y.~C(x,~z:~y))}
{R(x) \vdash \exists y,~t.~L(B(x:~z,~t);~C(x,~z:~y)))}

Пусть имеется обощенный оператор суперпозиции в определении предиката A:

\numformula{suppred1} {
A(x:~z,~v) \equiv P(x)~\{ \ldots ~ A(u:~z1,~v1);~B(u,~z1:~y) \ldots\}~Q(x,~z,~v)
}

\ruleII{FS5}
{R(u,~x,~v1,~y) \vdash m(u)<m(x) \land P(u);}
{R(u,~x,~v1,~y) \land Q(u,~z1,~v2) \vdash L(B(u,~z1:~y)) \land v1=v2}
{Induct(x) \land R(u,~x,~v1,~y) \vdash L(A(u:~z1,~v1);~B(u,~z1:~y))}

Допустим, спецификация \lnkformula{suppred1} для предиката A является тотальной.

\ruleII{FE8}
{R(u,~x) \vdash m(u)<m(x) \land P(u);}
{R(u,~x) \land Q(u,~z1,~v) \vdash \exists y.~L(B(u,~z1:~y))}
{Induct(x) \land R(u,~x) \vdash \exists z,~y.~L(A(u:~z,~v);~B(u,~z:~y))}

\subsection{Вызов функции}

Допустим A(x: z) - корректный нерекурсивный вызов предиката.

\ruleII{FF1}
{Corr(A(x:~z),~P(x),~Q(x,~z));}
{R(x,~y) \vdash P(x);~~R(x,~y) \land Q(x,~z) \vdash L(B(z,~y:~u))}
{R(x,~y) \vdash L(B(A(x),~y:~u))}

Пусть имеется рекурсивный вызов функции A(u) в определении предиката A:

\begin{center}
$ A(x:~y) \equiv P(x)~\{ \ldots B(u,~A(u):~z) \ldots \}~Q(x,~y) $
\end{center}

\ruleIII{FF2}
{T(P(x),~Q(x,~y));}
{R(u,~x,~z) \vdash m(u)<m(x) \land P(u);}
{R(u,~x,~z) \land Q(u,~y) \vdash L(B(u,~y:~z))}
{Induct(x) \land R(u,~x,~z) \vdash L(B(u,~A(u):~z))}

\section{Алгоритм генерации формул корректности на примере}

Дадим иллюстацию работы алгоритма на примере программы умножения натуральных чисел через сложение:

\begin{lstlisting}
mult(nat a, b: nat c)
pre a >= 0 & b >= 0
{
    if (a = 0)
        c = 0
    else
        c = b + mult(a – 1, b);
}
post c = a * b
measure a;
\end{lstlisting}

Представим начальную часть теории для определения предиката mult:

\begin{lstlisting}
module mult;
formula P(nat a, b) = a >= 0 & b >= 0;
formula Q(nat a, b, c) = c = a*b;
formula m(nat a: nat) = a;
\end{lstlisting}

Тело предиката Умн представлено условным оператором, соответственно, цель доказать следующее утверждение:

\begin{center}
$ Corr(mult,~t,~If~(a=0)~c=0~else~c=b+mult(a-1,~b),~P(a,~b),~Q(a,~b,~c)) $
\end{center}

В соответстви с правилом \textbf{QC}, доказательство данного утверждения разбивается на 2 ветки:

\numformula{branch1}
{Corr(mult,~t,~c=0,~P(a,~b) \land a=0,~Q(a,~b,~c))}
\numformula{branch2}
{Corr(mult,~t,~c=b+mult(a-1,~b),~P(a,~b) \land a\ne0,~Q(a,~b,~c))}

Ветка \lnkformula{branch1} представляет собой утверждение о корректности оператора, не содержащего рекурсивного вызова. Ввиду этого, утверждение заменяется на более простое:

\begin{center}
$ Corr(c=0,~P(a,~b) \land a=0,~Q(a,~b,~c)) $
\end{center}

По данному утверждению формируются две леммы, которые добавляются к основной теории:

\begin{lstlisting}
lemma forall nat a, b. P(a, b) & a = 0 => exists nat c. c = 0;
lemma forall nat a, b, c. P(a, b) & a = 0 & c = 0 => Q(a, b, c);
\end{lstlisting}

Здесь первая лемма - суть тотальности оператора, а вторая - его корректности. В данном случае, лемму тотальности можно было не добавлять к теории, ибо для оператора присваивания она тождественно истина.

Оператор ветки \lnkformula{branch2} содержит рекурсивный вызов предиката mult, поэтому исходный оператор представляется оператором суперпозиции, с целью изъять оператор вызова предиката:

\begin{lstlisting}
mult(a-1, b, nat d);
c = b + d;
\end{lstlisting}

Теперь утверждение корректности выглядит так:

\begin{center}
$ Corr(mult,~t,~mult(a-1,~b,~d);~c=b+d,~P(a,~b) \land a\ne0,~c=a*b) $
\end{center}

Доказательство данного утверждения ведется по правилу \textbf{QSB}, ввиду наличия спецификации у оператора вызова. По данному правилу сразу формируется лемма, истинность которой гарантирует выполнение предусловия оператора mult, по мере углубление рекурсии:

\begin{lstlisting}
lemma forall nat a, b. P(a, b) & a != 0
                       => m(a - 1) < m(a) & P(a - 1, b);
\end{lstlisting}

Так же, данное парвило требует провести следующие доказательства:

\numformula{branch3}
{Corr(mult,~t,~mult(a-1,~b,~d),~P(a-1,~b),~Q(a-1,~b,~d))}
\numformula{branch4}
{Corr(mult,~t,~c=b+d,~P(a,~b) \land a\ne0 \land ~Q(a-1,~b,~d),~Q(a,~b,~c))}

В данном случае, проводить доказательство корректности оператора вызова \lnkformula{branch3} не имеет смысла, т.к. вызов рекурсивен. Корректность оператора присваивания \lnkformula{branch4} выражается в виде двух, уже знакомых нам лемм:

\begin{lstlisting}
lemma forall nat a, b, d. P(a, b) & a != 0 & Q(a - 1, b, d)
                          => exists nat c. c = b + d;
lemma forall nat a, b, d, c. P(a, b) & a != 0 & Q(a - 1, b, d)
                             & c = (b + d) => Q(a, b, c);
\end{lstlisting}

Итоговый вариант теории:

\begin{lstlisting}
module mult;
formula P(nat a, b) = a >= 0 & b >= 0;
formula Q(nat a, b, c) = c = (a * b);
formula m(nat a : nat) = a;
lemma forall nat a, b. P(a, b) & a = 0
                       => exists nat c. c = 0;
lemma forall nat a, b, c. P(a, b) & a = 0 & c = 0
                          => Q(a, b, c);
lemma forall nat a, b. P(a, b) & a != 0
                       => m(a - 1) < m(a) & P(a - 1, b);
lemma forall nat a, b, d. P(a, b) & a != 0 & Q(a - 1, b, d)
                          => exists nat c. c = b + d;
lemma forall nat a, b, d, c. P(a, b) & a != 0 & Q(a - 1, b, d)
                             & c = (b + d) => Q(a, b, c);
\end{lstlisting}

\end{document}
